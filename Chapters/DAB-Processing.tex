% ----------------------------------------------------
% DAB Processing
% ----------------------------------------------------
\documentclass[class=report,11pt,crop=false]{standalone}
\input{../Style/ChapterStyle.tex}
\input{../FrontMatter/Glossary.tex}
\begin{document}
\ifstandalone
\tableofcontents
\fi
% ----------------------------------------------------
\chapter{Digital Audio Broadcasting: Processing Chain Design}
\epigraph{Nobody can build you the bridge over which you must cross the river of life, nobody but you alone.}%
    {\emph{---Friedrich Nietzsche}}
% ----------------------------------------------------

This chapter details the core design component of the project: a \gls{dab} processing chain. While the broader context of this report falls within the realm of \gls{pr}, the fundamental task at hand was to demodulate and remodulate a given \gls{dab} signal, in order to create a perfect reference signal of given recorded data. Fortunately, as outlined in the previous chapter, not all of the intricacies of the \gls{dab} standard were required to be understood or even considered for integration into a passive radar chain.

The design of the chain involved studying the \gls{dab} standard document from the \gls{etsi}~\cite{dabstandard}, as well as using a reference signal which was known to be perfectly modulated for initial testing. For some functionality, real-world data was also used for design and testing. For the sake of simplicity, the entire chain---including all the dimensions shown in this chapter---was designed around \gls{dab} Mode 1. Nonetheless, altering the chain for implementation with other modes will be trivial. All MATLAB functions were designed with a \texttt{dab\_mode} input, if necessary, to allow for easy changes in future designs. Note, however, that this mode input parameter is not shown in any of the upcoming diagrams.

\section{Overview}
Within the \gls{dab} processing chain, three main functional blocks were identified: pre-processing, demodulation, and remodulation. The first block reads in a \gls{dab} recording of \gls{iq} data saved as a binary file, and outputs a single \gls{dab} frame from this file. This frame can then be input to the demodulate block, which extracts the \gls{dab} data from it. This data is not the decoded information from the \gls{dab} recording---such as the audio signal---rather, it is simply an extracted bitstream. This bitstream can then be perfectly reconstructed as a \gls{dab} frame, by the remodulate block. A diagrammatic overview of this chain is given in Figure~\ref{fig:BD_Overview_All}.

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
      \input{../Images/BD_Overview_All-embed.pdf_tex}}
  \caption{Block diagram showing entire DAB processing chain}
  \label{fig:BD_Overview_All}
\end{figure}

Notice in the figure that each of the aforementioned blocks---the pre-process, demodulate, and remodulate blocks---was created from a collection of smaller sub-blocks. These sub-blocks were designed to perform simpler tasks individually, and were written as relatively short MATLAB functions. This atomic-function approach had a host of benefits for the design, debugging, and validation of the chain, and added layers of abstraction for the larger system.

Each of the three blocks will be unpacked in the sections that follow this one, with subsections dedicated to the relevant sub-blocks.

\section{Pre-processing \label{sect:dab-proc_preprocessing}}
\subsection{Overview}
The pre-processing chain was designed to read in an \gls{iq} data file, synchronize it appropriately, and extract a single frame from it. Note that in an actual \gls{pr} system---where this \gls{dab} processing chain would be only a small part of a larger chain---this block would be markedly different. If nothing else, a real-world chain would probably stream the \gls{iq} data, rather than read it from a pre-recorded file. Moreover, a real chain might process several \gls{dab} frames at once. However, such details are largely context-specific, and it would be superfluous to include every use-case in this report. Importantly, the other two blocks---used to demodulate and remodulate---would mostly remain the same in various other scenarios. Thus, to make matters simpler, the pre-processing block was designed to be straightforward: to read in data and extract a single frame. That is not to say the block is trivial, and there were some important design decisions made for it.

The pre-processing block has four key stages: reading in \gls{iq} data from a binary file, resampling this data if necessary, detecting the location of the \gls{prs} and thus synchronizing the recording, and then extracting a \gls{dab} frame accordingly. This pipeline is shown graphically in Figure~\ref{fig:BD_Preprocess_All}.

\begin{figure}[htbp]
    \centering
    \captionsetup{type=figure}
    \def\svgwidth{\linewidth}
    {\setstretch{0.7} % Line spacing
        \input{../Images/BD_Preprocess_All-embed.pdf_tex}}
    \caption{Block diagram showing preprocessing section of processing chain}
    \label{fig:BD_Preprocess_All}
\end{figure}

\subsection{Reading IQ data from file \label{subsect:dab-proc_iq-read}}
The first sub-block is called \texttt{iq\_read}, and, as mentioned previously, would likely be very different in a real \gls{pr} chain. Nonetheless, here it reads in a \gls{dab} recording from a binary file, and outputs so-called "raw" \gls{iq} data. No changes are made to this data in this function, and it essentially just abstracts MATLAB's file-handling functionality conveniently.

As a minor note, one must remember that a \gls{dab} recording contains \gls{iq} data, which is complex-valued. Since a binary file cannot store such a datatype, it will usually be stored as pairs of numbers. To read this correctly in MATLAB, one can use the simple code shown in Listing~\ref{code:iq_read}.

\begin{lstlisting}[caption={Creating a complex data array with the values read from a binary file},label={code:iq_read}]
iq_data_raw = data_from_file(1:2:end) + 1j*data_from_file(2:2:end);
\end{lstlisting}

Though it is not shown in the pre-processing block diagrams, the MATLAB function for \texttt{iq\_read} also included some other input parameters for convenience, including the data-type of the binary file, the offset to skip in the file's data, the number of frames to read, and so on.

A perfect \gls{dab} recording that would be output from the \texttt{iq\_read} function is shown in Figure~\ref{fig:plots/perfect-dab-signal}, showing a handful of \gls{dab} frames. Notice the separation of successive frames by the distinct null symbols.

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \includegraphics[width=\linewidth]{plots/perfect-dab-signal.pdf}
  \caption{Time-domain plot of a handful of frames of a perfect \gls{dab} signal}
  \label{fig:plots/perfect-dab-signal}
\end{figure}

\subsection{Resampling IQ data \label{subsect:dab-proc_iq-resample}}
In order for one to utilise the \gls{fft} to demodulate an \gls{ofdm} symbol, certain requirements must be met. Recall that the window for a single symbol, notated as \(T_u\), is 2048 samples for \gls{dab} Mode 1. This means that a 2048-point \gls{fft} must be used, with a resulting 2048 points in the frequency domain. Recall also that \gls{ofdm} has a strict requirement for the spacing between adjacent carriers---\(1 \si{\kilo \hertz}\) for \gls{dab} Mode1. Notice, then, if the sample rate for the original signal is precisely set at \(F_s = 2.048 \si{\mega \hertz}\), for \gls{dab} Mode 1, then the bins from the \gls{fft} will be perfectly aligned on the \gls{ofdm} carriers---enabling proper demouldation.

However, in a real-world scenario, the desired sampling rate might not necessarily be used in the receiver. Thus, in such a situation, the \gls{iq} data must be resampled. Consider an original sampling rate of \(F_s\), a desired sampling rate of \(\tilde{F_s} = 2.048 \si{\mega \hertz}\), with \(F_s \ne \tilde{F_s}\), and with
\begin{equation}
  \frac{\tilde{F_s}}{F_s} = \frac{P}{Q}
\end{equation}
where \(P\) and \(Q\) are integers---preferably chosen such that \(P/Q\) is in its most reduced fractional form. Resampling, then, is equivalent to upsampling by a factor of \(P\), and thereafter downsampling by a factor of \(Q\).

Fortunately, MATLAB provides a neat abstraction of this process with the \texttt{resample(X, P, Q)} function, where \(X\) is a uniformly sampled signal, and \(P\) and \(Q\) are as defined above.

% -----------------
\subsection{Frame Synchronization via Phase Reference Symbol Detection \label{subsect:dab-proc_prs-detect}}

One of the most important parts of the entire \gls{dab} processing chain is correct time-synchronization. If the frame from the pre-processing block is misaligned, the entire demodulation process can break due to misalignment of the \gls{ofdm} symbols, thus causing havoc in the \gls{dqpsk} demodulation. Fortunately, the inclusion of a guard interval with cyclic prefixing provides some leeway, but errors can easily arise if one is not careful. It will later be shown how negatively a result is affected by the incorrect alignment of a \gls{dab} frame.

There are two mechanisms built into the \gls{dab} signal for synchronization, namely the \acrfull{ns} and the \acrfull{prs}. As specified in the \gls{dab} standard document~\cite{dabstandard}, the former symbol is to be used for so-called "coarse" synchronization---detecting an approximate location of the frame's beginning; whereas the latter symbol is used for "fine" synchronization---detecting the exact sample at which the frame starts. 

Naturally, for each of these detection processes, one cannot consider the entirety of a signal---stretching back from the dawn of time to the eventual collapse of the universe far in the future---more than just practically impossible, it would be unnecessary. Instead only a chunk of the data can be considered at once, as a subset of the longer signal. This process is termed "windowing," where the signal is truncated to a finite domain over which it will be examined. Let the length of this window be notated\footnote{The is not necessarily standardised notation.} as \(T_w\), and let the interval between successive windows be called the "advancement interval", \(T_a\). Graphically, these values are depicted in Figure~\ref{fig:window_advance_illustration}.

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
      \input{../Images/window_advance_illustration.pdf_tex}}
      \caption{}
      \label{fig:window_advance_illustration}
\end{figure}

In order not to skip any sections of the signal, it is clear that the following must hold:
\begin{equation}
  T_a \le T_w
\end{equation}

Consider firstly the detection of the \gls{ns}. Recall that this symbol is a period in the signal during which all \gls{ofdm} carriers are turned off and no power is transmitted. On the receiver's end, there will still be noise recorded from the environment and elsewhere, but the received power over the length of the null symbol, \(T_\textrm{null}\), will be significantly less than in other parts of the signal. Hence, in order to detect this symbol, one can calculate the average power, \(P_{n_0}\), starting at index \(n_0\) over a window of \(T_w = T_\textrm{null}\):
\begin{equation}
  P_{n_0} = \frac{1}{T_w} \cdot \sum^{n_0 + T_w - 1}_{n=n_0} \left| x[n] \right|^2
\end{equation}
where \(x[n]\) is the sampled signal, windowed on the domain \([n_0, n_0 + T_w)\). This window can be moved along the original signal, in increments of \(T_a\). Since the \gls{ns} only provides a coarse result, and further synchronisation steps would always be required, the specific value of \(T_a\) is not too important, provided it is less than or equal to \(T_w\). When the average power of a window decreases below a particular threshold---for example, it could be compared to the average power of a \emph{frame}-lengthed chunk of the signal---the \gls{ns} has been approximately detected. If things are working correctly, the symbol detection should occur within the first \(T_f\) samples---if not, there is a problem.

An outline of the coarse detection process is given in Algorithm~\ref{alg:null_symbol_detect}.

\begin{figure}[ht]
  \vspace{0.5cm}
  \centering
  \captionsetup{type=figure}
  \begin{minipage}{.75\linewidth}
    \begin{algorithm}[H]
      \caption{Coarse Frame Synchronization via Null Symbol Detection\label{alg:null_symbol_detect}}

      \DontPrintSemicolon
      \SetAlgoLined
      \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

      \Input{A sampled \gls{dab} signal, $x[n]$}
      \Output{The approximate index of the first \acrlong{ns}}
      \BlankLine
          \Begin{
          $P_\textrm{frame} \leftarrow \frac{1}{T_f} \cdot \sum^{T_f - 1}_{n=0} \left| x[n] \right|^2$\;
          $n_0 \leftarrow 0$ \;
          \While(){$(n_0 < T_f)$}{
            $P_{n_0} \leftarrow \frac{1}{T_w} \cdot \sum^{n_0 + T_w - 1}_{n=n_0} \left| x[n] \right|^2$ \;

            \eIf{$(\gamma P_{n_0} < P_\mathrm{frame})$}{
              \Return $n_0$ \;
            }{
              $n_0 \leftarrow n_0 + T_a$ \;
            } 
          }
        }
      \vspace{0.5cm}
    \end{algorithm}
  \end{minipage}
\end{figure}

Consider next the detection of the \gls{prs}. Because this symbol is precisely defined by the \gls{dab} standard, it was known \emph{a priori} and thus could be detected via a Matched Filtering process, which is essentially a time-domain correlation. Conceptually, this entailed designing a filter, \(H(\omega)\), based on the \gls{prs}:
\begin{equation}
  H(\omega) = R^*(\omega)
\end{equation}
where \(R^*(\omega)\) was the conjugate of the continuous-time Fourier transform of the \gls{prs}. Of course, since the system was implemented digitally, the filter had to be defined discretely:
\begin{equation}
  H[k] = R^*[k] = \mathrm{DFT} \{ r[n] \}^*
\end{equation}

Since the \gls{dft} is a \(\mathbb{C}^N \rightarrow \mathbb{C}^N\) transformation, the filter length---and thus the window size, \(T_w\)---is constrained to the length of \(r[n]\). This length is equal to \(T_u\), the "useful symbol length" in the \gls{dab} standard.

The output of the Matched Filter in the Fourier domain, \(Y[k]\), for a given input signal, \(x[n]\), can be calculated via a simple Hadamard (pointwise) product:
\begin{equation}
  Y[k] = H[k] \odot X[k] = H[k] \odot \mathrm{DFT} \{ x[n] \}
\end{equation}

The output of this filter in time, \(y[n]\), will contain a peak value at the location within \(x[n]\) where \(r[n]\) is most highly correlated. In an arbitrary section of the \gls{dab} signal, the output will simply be noise, as the signals are not correlated; however, in a section containing the \gls{prs}, the peak value will be noticeably larger than surrounding values, even when using a non-perfect recording. Figure~\ref{fig:mf_out_good} shows an example of the filtering process when the \gls{prs} falls within the window of \(x[n]\).

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \begin{subfigure}[t]{\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=0.7\linewidth]{plots/mf_out_good_signal.pdf}
    \caption{Input to Matched Filter, \(x[n]\)}
    \label{fig:mf_out_good_signal}
  \end{subfigure}%
  \\
  \begin{subfigure}[t]{\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=0.7\linewidth]{plots/mf_out_good_peak.pdf}
    \caption{Output from Matched Filter, \(y[n]\), with peak detected}
    \label{fig:mf_out_good_peak}
  \end{subfigure}
  \caption{Plots showing the input to- and output from the Matched Filter, when the \gls{prs} symbol is detected}
  \label{fig:mf_out_good}
\end{figure}

By moving a window of length \(T_w = T_u\) across the input \gls{dab} signal until a peak is detected in the Matched Filter output, one can locate the \gls{prs}---and thus the beginning of the \gls{dab} frame---precisely. This detection should occur within the first \(T_f\) samples. There are two important points to make here. Firstly, note that the magnitude of the Matched Filter's output, \(|y[n]|\), decreases as the offset of the recorded \gls{prs} within the window increases. That is, suppose the \gls{prs} begins at the sample index \(n_p\). If the windowed \gls{dab} signal, \(x[n]\), covers the domain \(n \in [n_p, n_p + T_u]\), then \(x[n]\) is perfectly correlated with the \gls{prs} (ignoring noise in the recording); thus, the output of the Matched Filter will be large. However, as \(n_p\) increases, less of the \gls{prs} signal will be included in \(x[n]\), and the correlation peak will decrease. The smaller the correlation peak, the less distinct it will be from other peaks, and the less likely it will be successfully found.

Secondly, notice that the peak of the Matched Filter output, in Figure~\ref{fig:mf_out_good_peak}, does not occur at the onset of the input signal, \(x[n]\); rather, it occurs around 500 samples later. This was expected, due to the inclusion of a guard interval---since the Matched Filter, \(H[k]\), is defined around the original \gls{prs} signal of length~\(T_u\), without the guard interval. However, unfortunately, this causes an unwanted effect in the detection process. Consider a situation in which \(x[n]\) only contains the guard interval of the \gls{prs}, before the actual "useful" symbol begins, as shown in Figure~\ref{fig:mf_out_prefix-problem_signal}.

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \begin{subfigure}[t]{\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=0.7\linewidth]{plots/mf_out_prefix-problem_signal.pdf}
    \caption{Input to Matched Filter, \(x[n]\)}
    \label{fig:mf_out_prefix-problem_signal}
  \end{subfigure}%
  \\
  \begin{subfigure}[t]{\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=0.7\linewidth]{plots/mf_out_prefix-problem_peak.pdf}
    \caption{Output from Matched Filter, \(y[n]\), with peak erroneously detected}
    \label{fig:mf_out_prefix-problem_peak}
  \end{subfigure}
  \caption{Plots showing the input to- and output from the Matched Filter, when the \gls{prs} symbol is erroneously detected due to the guard interval}
  \label{fig:mf_out_prefix-problem}
\end{figure}

Notice that the peak identified in the Matched Filter output, seen in Figure~\ref{fig:mf_out_prefix-problem_peak}, is erroneous---the actual \gls{prs} has, in fact, not yet begun. Recall that the guard interval is duplicated from the tail-end of the original symbol; thus, the end of the \gls{prs} in the Matched Filter has correlated with the guard interval of the input signal, \(x[n]\). Though this peak is not massive, it can nevertheless be incorrectly identified as the beginning of the \gls{dab} frame.

Both of these points---the decreasing correlation peak, and the guard interval problem---motivate the choice of the advancement interval to be less than the window period. Of course, there is a trade-off, as a shorter advancement interval increases the computation required to detect the \gls{prs}. For this project's implementation of the \gls{dab} processing chain, the values were chosen as \(T_a = \frac{1}{2} T_w\). This ensures that any small peak occurring in the second half of a window interval is guaranteed to occur again, as a much larger peak, in the first half of the next interval. Therefore, the threshold for a "true peak" value can be stricter, which also solves the guard interval problem.

An outline of the \gls{prs} detection process is given in Algorithm~\ref{alg:prs_detect}.

\begin{figure}[ht]
  \vspace{0.5cm}
  \centering
  \captionsetup{type=figure}
  \begin{minipage}{.75\linewidth}
    \begin{algorithm}[H]
      \caption{Fine Frame Synchronization via \gls{prs} Detection\label{alg:prs_detect}}

      \DontPrintSemicolon
      \SetAlgoLined
      \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

      \Input{A sampled \gls{dab} signal, $x[n]$; The \gls{prs}, $R[k]$}
      \Output{The exact index of the first \gls{prs} in $x[n]$}
      \BlankLine
          \Begin{
          
          $n_0 \leftarrow 0$ \;
          \While(){$(n_0 < T_f)$}{
            
            $X[k] \leftarrow \mathrm{FFT} \{x[n_0 : n_0 + T_u]\} $\;
            
            $Y[k] \leftarrow R^*[k] \odot X[k]$\;

            $y[n] \leftarrow \mathrm{iFFT} \{Y[k]\} $\;

            \eIf{$(\mathrm{max} |y[n]| > \gamma)$}{
              \Return $\mathrm{argmax} |y[n]|$ \;
            }{
              $n_0 \leftarrow n_0 + T_a$ \;
            }
          }
        }
      \vspace{0.5cm}
    \end{algorithm}
  \end{minipage}
\end{figure}

Recall that detection of the \gls{ns} was designed for coarse synchronisation, while the \gls{prs} was intended for fine synchronisation. Essentially, then, there were two broad algorithms for frame alignment: to locate the approximate beginning of a frame with the \gls{ns} and thereafter finely align the frame with the \gls{prs}, or to use only the \gls{prs} without first coarsely detecting the \gls{ns}. For a robust design decision between these two approaches, one should consider the various computational complexities involved in each of the algorithms, as well as possible optimisations that could be made. Nonetheless, for the sake of simplicity, the latter choice was taken in this project: to use only the \gls{prs} for detection. Further work could be done analysing the best decision to make, but such work was outside of the scope of this report.

Another important question when integrating the \gls{dab} processing chain into a larger \gls{pr} system is the regularity of frame synchronization. Ideally, one would only need to synchronize once, if the clock of the transmitter and receiver are perfectly accurate. Unfortunately, in real scenarios, there are a host of unwanted effects, including clock drift, that may cause synchronization errors over time. The other extreme is to synchronize on every frame---which is possible because every frame is preceded by both a \gls{ns} and a \gls{prs}. However, this may prove to be too computationally expensive. Naturally, fixed rules cannot be set for this decision, and are largely context-specific. Further details are thus omitted here.

\subsection{Frame Extraction \label{subsect:dab-proc_frame-extract}}
Once the index of the \gls{prs} has been detected, extracting a frame is trivial, as it simply entails subsetting the original data array. This block and subsection are included for the sake of completeness.


\section{Demodulation \label{sect:dab-proc_demodulate}}
\subsection{Overview}
The purpose of the demodulation block is to extract \gls{dab} "information" from a given frame. This not a \emph{decoder}, as it does not extract any audio signal or similar. Rather, it returns the bitstream with which the \gls{ofdm} carrier waves were modulated. Importantly, this demodulator block is not intended to stand alone, and its output is useless in isolation. Instead, the demodulation and remodulation blocks are designed to operate in tandem, where the output of the demodulate block is the input to the remodulate block. Ultimately, this is all for the purpose of perfectly reconstructing a given \gls{dab} frame, to be used in a \gls{pr} chain.

The demodulation pipeline has six key stages: the \gls{dab} frame is unpacked into a collection of symbols, which is then demultiplexed into \gls{ofdm} carriers, which are then demapped into \gls{dab} data via \gls{dqpsk} demodulation. Thereafter, this \gls{dab} data is interleaved in frequency, snapped to their closest \gls{dqpsk} values, and finally are put through an error-correction algorithm. The overview of this chain is given in Figure~\ref{fig:BD_Demod_All}. Take special note of the nomenclature for the variables before and after each block, as well as their dimensions---provided for \gls{dab} Mode 1.

\begin{figure}[htbp]
    \centering
    \captionsetup{type=figure}
    \def\svgwidth{\linewidth}
    {\setstretch{0.7} % Line spacing
        \input{../Images/BD_Demod_All-embed.pdf_tex}}
    \caption{Block diagram showing demodulation section of processing chain}
    \label{fig:BD_Demod_All}
\end{figure}

The details for each sub-block are given in the following sections.

\subsection{Symbols Unpacking \label{subsect:dab-proc_symbols-unpack}}
The purpose of this function is to split a \gls{dab} frame into its symbols, which can then be demultiplexed and further processed. This sub-block also includes the removal of guard intervals from the symbols, thus extracting only the "useful symbol" component. As a result, the function receives a vector of size \(1\times T_f\), and outputs a matrix of size \(L\times T_u\). Note that
\begin{equation}
  T_f \ne L\times T_u
\end{equation}
since the original frame length, \(T_f\), includes the guard intervals of length \(Tg\), as well as the \gls{ns}. Instead,
\begin{equation}
  T_f = L\times (T_u + T_g) + T_\mathrm{null}
\end{equation}

The symbol unpacking process is depicted graphically in figure~\ref{fig:symbols_unpack}.

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
      \input{../Images/symbols_unpack.pdf_tex}}
  \caption{Illustration of the \texttt{symbol\_unpack} functionality}
  \label{fig:symbols_unpack}
\end{figure}

In MATLAB, the unpacking process is fairly straightforward, with complications only arising in off-by-one errors. Consider the simple code segment in Listing~\ref{code:symbols_unpack} for this functionality.

\begin{lstlisting}[caption={Code used in the \texttt{symbols\_unpack} function}, label={code:symbols_unpack}]
function dab_symbols = symbols_unpack(dab_frame, dab_mode)
  % Pre-allocate space for the result
  dab_symbols = zeros(dab_mode.L, dab_mode.Tu);

  % Start after null & first guard interval
  ii = dab_mode.Tnull + dab_mode.Tg + 1;

  % Iterate through L symbols
  for l = 1:dab_mode.L
      % Read symbol of length Tu
      dab_symbols(l,:) = dab_frame(ii:ii+dab_mode.Tu-1);
      % Jump ahead 1 symbol, incl. guard (Ts = Tu + Tg)
      ii = ii + dab_mode.Ts;
  end
end
\end{lstlisting}

% -------------
\subsection{OFDM Demultiplexing \label{subsect:dab-proc_ofdm-demux}}
With the individual symbols extracted from the \gls{dab} frame, the \gls{ofdm} carriers can then be extracted via a \gls{fft} operation, as explained in the previous chapter. Consider first the case of a single symbol.

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/ofdm-carriers-perfect.pdf}
    \caption{Perfect Data}
    \label{fig:ofdm-carriers-perfect}
  \end{subfigure}%
  ~ 
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/ofdm-carriers-raw.pdf}
    \caption{Actual Data}
    \label{fig:ofdm-carriers-raw}
  \end{subfigure}
  \caption{Plots showing the magnitude of the \gls{ofdm} carriers for a single \gls{dab} symbol}
  \label{fig:dqpsk_demap_perfect}
\end{figure}

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \includegraphics[width=0.9\linewidth]{plots/ofdm-surface-perfect.png}
  \caption{Surface plot}
  \label{fig:ofdm-surface-perfect}
\end{figure}

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \includegraphics[width=0.9\linewidth]{plots/ofdm-surface-raw.png}
  \caption{Surface plot}
  \label{fig:ofdm-surface-raw}
\end{figure}



\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
      \input{../Images/ofdm_demux.pdf_tex}}
  \caption{Illustration of the \texttt{ofdm\_demux} functionality}
  \label{fig:ofdm_demux}
\end{figure}



\subsection{DQPSK Demapping \label{subsect:dab-proc_dqpsk-demap}}


\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/ofdm-carriers-perfect-angle.pdf}
    \caption{Perfect Data}
    \label{fig:ofdm-carriers-perfect-angle}
  \end{subfigure}%
  ~ 
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/ofdm-carriers-raw-angle.pdf}
    \caption{Actual Data}
    \label{fig:ofdm-carriers-raw-angle}
  \end{subfigure}
  \caption{Plots showing the phase of the \gls{ofdm} carriers for a single \gls{dab} symbol}
  \label{fig:dqpsk_demap_perfect}
\end{figure}


\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/dqpsk_demap_perfect-1.pdf}
    \caption{}
    \label{fig:dqpsk_demap_perfect-1}
  \end{subfigure}%
  ~ 
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/dqpsk_demap_perfect-2.pdf}
    \caption{}
    \label{fig:dqpsk_demap_perfect-2}
  \end{subfigure}
  ~ 
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/dqpsk_demap_perfect-2over1.pdf}
    \caption{}
    \label{fig:dqpsk_demap_perfect-2over1}
  \end{subfigure}
  \caption{}
  \label{fig:dqpsk_demap_perfect}
\end{figure}


\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/dqpsk_demap_rtl-1.pdf}
    \caption{}
    \label{fig:dqpsk_demap_rtl-1}
  \end{subfigure}%
  ~ 
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/dqpsk_demap_rtl-2.pdf}
    \caption{}
    \label{fig:dqpsk_demap_rtl-2}
  \end{subfigure}
  ~ 
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/dqpsk_demap_rtl-2over1.pdf}
    \caption{}
    \label{fig:dqpsk_demap_rtl-2over1}
  \end{subfigure}
  \caption{}
  \label{fig:dqpsk_demap_rtl}
\end{figure}


\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/dqpsk_demap_raw-1.pdf}
    \caption{}
    \label{fig:dqpsk_demap_rtl-1}
  \end{subfigure}%
  ~ 
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/dqpsk_demap_raw-2.pdf}
    \caption{}
    \label{fig:dqpsk_demap_rtl-2}
  \end{subfigure}
  ~ 
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \captionsetup{type=figure}
    \includegraphics[width=\linewidth]{plots/dqpsk_demap_raw-2over1.pdf}
    \caption{}
    \label{fig:dqpsk_demap_raw-2over1}
  \end{subfigure}
  \caption{}
  \label{fig:dqpsk_demap_raw}
\end{figure}

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
      \input{../Images/dqpsk_demap.pdf_tex}}
  \caption{}
  \label{fig:dqpsk_demap}
\end{figure}


\subsection{Frequency Deinterleaving \label{subsect:dab-proc_freq-deinterleave}}

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
      \input{../Images/freq_deinterleave.pdf_tex}}
  \caption{Frequency deinterleaving}
  \label{fig:freq_deinterleave}
\end{figure}

\subsection{DQPSK Snapping \label{subsect:dab-proc_dqpsk-snap}}

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \includegraphics[width=0.8\linewidth]{plots/dqpsk_snap_rtl.pdf}
  \caption{}
  \label{fig:dqpsk_snap_rtl}
\end{figure}

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
      \input{../Images/dqpsk_snap_rtl-alt.pdf_tex}}
  \caption{}
  \label{fig:dqpsk_snap_rtl-alt}
\end{figure}

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
      \input{../Images/dqpsk_snap.pdf_tex}}
  \caption{\gls{dqpsk} snapping}
  \label{fig:dqpsk_snap}
\end{figure}

\subsection{Error Correction \label{subsect:dab-proc_error-correct}}

\section{Remodulation \label{sect:dab-proc_remodulate}}

\subsection{Overview}

\begin{figure}[htbp]
    \centering
    \captionsetup{type=figure}
    \def\svgwidth{\linewidth}
    {\setstretch{0.7} % Line spacing
        \input{../Images/BD_Remod_All-embed.pdf_tex}}
    \caption{Block diagram showing remodulation section of processing chain}
    \label{fig:BD_Remod_All}
\end{figure}

\subsection{Frequency Interleaving \label{subsect:dab-proc_freq-interleave}}

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
  \input{../Images/freq_interleave.pdf_tex}}
  \caption{Frequency interleaving process}
  \label{fig:freq_interleave}
\end{figure}

\subsection{DQPSK Mapping \label{subsect:dab-proc_dqpsk-map}}

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
  \input{../Images/dqpsk_map.pdf_tex}}
  \caption{\gls{dqpsk} mapping process}
  \label{fig:dqpsk_map}
\end{figure}

\subsection{OFDM Multiplexing \label{subsect:dab-proc_ofdm-mux}}

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
  \input{../Images/ofdm_mux.pdf_tex}}
  \caption{\gls{ofdm} multiplexing process}
  \label{fig:ofdm_mux}
\end{figure}

\subsection{Symbols Packing \label{subsect:dab-proc_symbols-pack}}

\begin{figure}[htbp]
  \centering
  \captionsetup{type=figure}
  \def\svgwidth{\linewidth}
  {\setstretch{0.7} % Line spacing
  \input{../Images/symbols_pack.pdf_tex}}
  \caption{Symbols packing process}
  \label{fig:symbols_pack}
\end{figure}

\section{Summary}

% ----------------------------------------------------
\ifstandalone
\bibliography{../Bibliography/References.bib}
\printnoidxglossary[type=\acronymtype,nonumberlist]
\fi
\end{document}
% ----------------------------------------------------